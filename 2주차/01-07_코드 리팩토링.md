## **문제 3️⃣ : parallelStream은 무조건 빠른가?**

<img width="1108" height="1159" alt="image" src="https://github.com/user-attachments/assets/4181c1a8-09a1-4c9c-852e-7ceafe7b00d7" />


<aside>

- parallelStream()이 항상 빠른 것은 아님
- 실제로는 **오버헤드 비용** 존재
</aside>

### `parallelStream()` ?

- `parallelStream()`은 내부적으로 **여러 스레드**를 써서 작업을 나눠 처리하는 방식
    - 여러 스레드를 쓰기 때문에 비동기처럼 보이지만, 실제로는 결과를 기다리는 **동기식 병렬 처리 방식임**

`parallelStream()`은 무조건 빠른 게 아니라, 병렬화 인한 성능적 오버헤드가 존재함

- 병렬 스트림은 내부적으로 작업을 splitting하고, 여러 스레드로 분배해서 결과를 merge 하는 과정을 거침
    - ForkJoinPool 이라는 병렬 처리용 스레드 풀을 이용하여 CPU 사용률을 극대화
- **데이터가 작거나 작업이 가벼우면 오히려 느려질 수 있다.**

## `parallelStream()` 이 유리한 경우

- 데이터가 큼
- 연산이 CPU를 많이 씀
- 공유 자원/락이 거의 없음

## `parallelStream()` 실험 결과

```java
package step02;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Speed {

	public static void main(String[] args) {
		List<Integer> small =
                IntStream.rangeClosed(1, 10)
                         .boxed()
                         .collect(Collectors.toList());

        long smallSeqStart = System.nanoTime();
        long smallSeqSum = small.stream()
                .mapToLong(n -> (long) n * n)
                .sum();
        long smallSeqEnd = System.nanoTime();

        long smallParStart = System.nanoTime();
        long smallParSum = small.parallelStream()
                .mapToLong(n -> (long) n * n)
                .sum();
        long smallParEnd = System.nanoTime();

        System.out.println("=== Small dataset ===");
        System.out.println("Sequential time : " + (smallSeqEnd - smallSeqStart) + " ns");
        System.out.println("Parallel time   : " + (smallParEnd - smallParStart) + " ns");
        System.out.println();

        List<Integer> large =
                IntStream.rangeClosed(1, 1_000_000)
                         .boxed()
                         .collect(Collectors.toList());

        long largeSeqStart = System.nanoTime();
        long largeSeqSum = large.stream()
                .mapToLong(Speed::heavyWork)
                .sum();
        long largeSeqEnd = System.nanoTime();

        long largeParStart = System.nanoTime();
        long largeParSum = large.parallelStream()
                .mapToLong(Speed::heavyWork)
                .sum();
        long largeParEnd = System.nanoTime();

        System.out.println("=== Large dataset ===");
        System.out.println("Sequential time : " + (largeSeqEnd - largeSeqStart) + " ns");
        System.out.println("Parallel time   : " + (largeParEnd - largeParStart) + " ns");

        System.out.println("\nCPU cores: " + Runtime.getRuntime().availableProcessors());
	}
	private static long heavyWork(int n) {
        long v = n;
        for (int i = 0; i < 30; i++) {
            v = (v * 31 + 7) ^ (v >>> 3);
        }
        return v;
    }

}
```

### 1. 백만 개의 데이터

<img width="456" height="220" alt="image" src="https://github.com/user-attachments/assets/3b992383-52b1-45a8-acfc-0c6b8f02e59f" />


### 2. 5백만 개의 데이터

<img width="444" height="220" alt="image" src="https://github.com/user-attachments/assets/763e959c-7641-45b2-9ad7-01427c38add0" />


### 3. 천만 개의 데이터

<img width="436" height="226" alt="image" src="https://github.com/user-attachments/assets/c2e737e8-9506-4060-b963-e62344e2f42c" />


### 결론💡

<aside>

- 작은 데이터 + 가벼운 연산 → `stream()`
- 큰 데이터 + CPU 연산 → `parallelStream()`
- I/O 작업은 병렬 처리 효과 거의 없음
</aside>

---

## **문제 5 : Optional을 예외처리 없이 그냥 get() 하면?**

<img width="1087" height="1255" alt="image" src="https://github.com/user-attachments/assets/e1e6ffbc-2bbf-44e8-85f0-f0bbc613935d" />


Java Stream의 `findFirst()`, `findAny()`, `reduce()` 같은 종단 연산은 **값이 없을 수도 있기 때문에 `Optional<T>`를 반환함**

- Optional: “값이 있을 수도 있고, 없을 수도 있다”를 명시적으로 표현하는 컨테이너
    - null을 없애는 것이 아닌 null 가능성을 메서드 시그니처만 보고 알 수 있음
    - Optional을 통해 가능성을 명시하기 때문에 개발자가 개발 시, NoSuchElementException 방지 가능

<aside>


💡 따라서 첫 번째 사진에서 `NoSuchElementException` 이 발생하는 이유는 예외 처리가 안되어 있는 Optional을 `get()` 으로 호출했기 때문임

</aside>

### 올바른 출력을 위한 예외 처리 방식

1. `isPresent()` 체크
    1. **의미**: 값이 있는지 먼저 확인
    - **특징**
        - 가장 직관적
        - `get()`을 여전히 직접 호출해야 함
    - **단점**
        - `Optional`을 썼는데도 `null` 체크 스타일과 크게 다르지 않음
        - 코드가 장황해짐
2. `orElse()` / `orElseGet()`
    1. **의미**: 값이 없으면 기본값 제공
    - **차이**
        - `orElse()` → 기본값 **항상 생성**
        - `orElseGet()` → 필요할 때만 **지연 생성**
    - **단점**
        - 기본값이 의미 없는 경우엔 부적절할 수 있음
3. `ifPresent()`
    1. **의미**: 값이 있을 때만 동작 실행
    - **특징**
        - 반환값 없음 (`void`)
        - 사이드 이펙트(출력, 로깅, 저장)에 적합
    - **장점**
        - 가장 함수형 스타일
        - `get()` 완전 제거
    - **단점**
        - 값이 없을 때의 처리 불가

### 결론

<aside>

💡 `Optional` 이 존재하는 경우, `NoSuchElementException` 의 발생 방지를 위해 상황에 맞는 예외 처리가 필요함

</aside>

---

## **문제 6️⃣ parallelStream + ArrayList 위험한 이유**

<img width="1346" height="1391" alt="image" src="https://github.com/user-attachments/assets/2d8eb1ba-c875-4225-8c46-c56f9ce2f1f1" />


### 첫 번째 코드의 문제점 (ArrayList의 문제점)

`ArrayList`는 **thread-safe** 하지 않음

- 여러 스레드가 동시에 `add()`하면 내부 상태가 망가질 수 있음
- 병렬 스트림에서는 여러 스레드가 동시에 `add()`를 실행
    - 값 누락, 덮어쓰기, `size` 불일치 등의 교착 상태 (Race Condition) 발생 가능
- `ArrayList` 이외의 기본 컬렉션 프레임워크(`HashSet`,`HashMap` 등)은 대부분 싱글 스레드 환경에서 사용할 수 있도록 설계되었음
    - 멀티스레드 환경에서 안전하지 않음

### 두 번째 코드의 문제 해결 방법 (`CopyWriteArrayList` )

`CopyWriteArrayList` 는  thread-safe collection 중 하나로 add()할 때마다 내부 배열을 **복사해서 새로 만들어** 넣는 방식임

- 여러 스레드가 동시에 `add()` 해도 괜찮음
- 다만 `add()` 시, 전체를 복사하기 때문에 쓰기 속도가 매우 느려짐
    - 읽기가 쓰기보다 월등히 많을때 유리

### 결론

<aside>


💡 병렬 처리 시, 교착 상태를 방지하기 위해서 thread-safe collection을 사용해야됨

</aside>

---

## Appendix: CopyWriteArrayList 외의 thread-safe collection

### 1. `Collections.synchronizedXXX()`

- 자바에서는 `Collections.synchronizedXXX()` 메서드를 통해 컬렉션을 동기화된 컬렉션으로 감싸서 사용할 수 있음
- synchronized 컬렉션은 **컬렉션 전체에 락을 걸기 때문에** 멀티스레드 환경에서 안전하긴 하나 병렬 처리 성능은 떨어짐

### 2. `ConcurrentHashMap`, `ConcurrentLinkedQueue`

- `java.util.concurrent` 패키지에서는 `ConcurrentHashMap`, `ConcurrentLinkedQueue`와 같은 **동시성 컬렉션(concurrent collection)** 을 제공
- 이 컬렉션들은 **부분적인 잠금 및 CAS(Compare And Swap) 기반 구조**를 사용하여 멀티스레드 환경에서도 안전하면서 병렬적인 작업 수행이 가능
    - CAS 기반 구조: 공유 데이터의 값을 바꾸기 전에 ‘지금 값이 내가 예상한 값인지’를 비교하고, 맞으면 교체하는 방식

---

## Appendix2: TroubleShooting

🚨처음에 ParallelStream을 실험할 때, `nanoTime()` 대신 `System.CurrentTimeMilis()` 를 사용하여서 시간을 체크 할 수 없었음

🚒 연산이 매우 빠르게 일어났기 때문에 ms 단위로 측정했을 때 0이 나오는 상황이 있었음

`nanoTime()` 으로 바꾼 후 시간 체크가 가능해짐

<aside>

💡 각 상황에 맞는 시간 단위를 고려해서 성능 체크를 해야겠다고 생각했음

</aside>
